<program>  --->					<moduleDeclarations><otherModules><driverModule><otherModules>
<moduleDeclarations>  --->		<moduleDeclaration><moduleDeclarations> | ε
<moduleDeclaration>   --->		DECLARE MODULE ID SEMICOL
<otherModules>  --->			<module><otherModules> | ε
<driverModule>  --->			DRIVERDEF DRIVER PROGRAM DRIVERENDDEF<moduleDef>
<module>  --->					DEF MODULE ID ENDDEF TAKES INPUT SQBO<input_plist> SQBC SEMICOL<ret><moduleDef>
<ret>  --->						RETURNS SQBO<output_plist> SQBC SEMICOL | ε
<input_plist>  --->				ID COLON<dataType><N1>   //N! intead of <input_plist1>
<N1>  --->						COMMA ID COLON<dataType><N1> | ε
<output_plist>  --->			ID COLON<type><N2>      //output plist 1 in N2
<N2>  --->						COMMA ID COLON<type><N2> | ε
<dataType>  --->				INTEGER | REAL | BOOLEAN | ARRAY SQBO<range_arrays> SQBC OF<type>       //range 1 is range range_arrays
<range_arrays>	--->			<index>RANGEOP<index>
<type>  --->					INTEGER | REAL | BOOLEAN
<moduleDef>  --->				START<statements> END
<statements>  --->				<statement><statements> | ε
<statement>  --->				<ioStmt> | <simpleStmt> | <declareStmt> | <condionalStmt> | <iterativeStmt>
<ioStmt>  --->					GET_VALUE BO ID BC SEMICOL | PRINT BO <var> BC SEMICOL
<var>  --->						<var_id_num> | <boolConstt>             //var is new, old var is var_id_num
<var_id_num>	--->			ID<whichId> | NUM | RNUM
<boolConstt>	--->			TRUE | FALSE                            //new rule
<whichId>  --->					SQBO <index> SQBC | ε
<simpleStmt>  --->				<assignmentStmt> | <moduleReuseStmt>
<assignmentStmt>   --->			ID<whichStmt>
<whichStmt>  --->				<lvalueIDStmt> | <lvalueARRStmt>
<lvalueIDStmt>  --->			ASSIGNOP<expression> SEMICOL
<lvalueARRStmt>   --->			SQBO<index> SQBC ASSIGNOP<expression> SEMICOL
<index>  --->					NUM | ID
<moduleReuseStmt>   --->		<optional> USE MODULE ID WITH PARAMETERS<idList>SEMICOL
<optional>  --->				SQBO<idList> SQBC ASSIGNOP | ε
<idList>  --->					ID<N3>                              //id list 1 is N3
<N3>  --->						COMMA ID<N3> | ε
<expression>  --->				<arithmeticOrBooleanExpr> | <U>     //<arithmeticOrBooleanExpr> was previously <booleanExpression>
<U>	--->						<unary_op><new_NT>                  //new nt is a new rule
<new_NT>	--->				BO<arithmeticExpr> BC | <var_id_num>
<unary_op>	--->				PLUS | MINUS
<arithmeticOrBooleanExpr>  --->	<AnyTerm><N7> | BO<arithmeticOrBooleanExpr> BC<N7>      //<AnyTerm> was previously <booleanVar>
<N7>  --->						<logicalOp><AnyTerm><N7> | ε                    //<N7> was <booleanExpression1>
<AnyTerm>  --->					<arithmeticExpr><N8> | <boolConstt>             //boolConstt is a new nt
<N8>  --->						<relationalOp><arithmeticExpr> | ε              //N8 is subbooleanexpresion1
<arithmeticExpr>  --->			<term><N4>                                      //<N4> is <arithmeticExpression1>
<N4>  --->						<op1><term><N4> | ε
<term>  --->					<factor><N5>                                    //<N5> is <term1>
<N5>  --->						<op2><factor><N5> | ε
<factor>  --->					<var_id_num> | BO <arithmeticExpr> BC                                 
<op1>  --->						PLUS | MINUS
<op2>  --->						MUL | DIV
<logicalOp>  --->				AND | OR
<relationalOp>  --->			LT | LE | GT | GE | EQ | NE
<declareStmt>  --->				DECLARE<idList> COLON<dataType> SEMICOL
<condionalStmt>  --->			SWITCH BO ID BC START<caseStmts><default> END       //New
<caseStmts>  --->				CASE<value> COLON<statements> BREAK SEMICOL<N9>
<N9>  --->						CASE<value> COLON<statements> BREAK SEMICOL<N9> | ε
<value>  --->					NUM | TRUE | FALSE
<default>  --->					DEFAULT COLON<statements> BREAK SEMICOL | ε
<iterativeStmt>  --->			FOR BO ID IN<range> BC START<statements> END | WHILE BO<arithmeticOrBooleanExpr> BC START<statements> END
<range>  --->					NUM RANGEOP NUM 